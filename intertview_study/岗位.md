<!-- TOC -->

- [运维的目的， ---------稳定](#运维的目的----------稳定)
- [运维 局限-------------与 公司 强耦合](#运维-局限-------------与-公司-强耦合)
- [互联网  的职位](#互联网--的职位)
- [计算机开发 速度之快--历史---  学习 才能赶上，](#计算机开发-速度之快--历史-----学习-才能赶上)
    - [agile 敏捷开发](#agile-敏捷开发)
    - [Waterfall 模式](#waterfall-模式)
    - [DevOps](#devops)
    - [pair-promgramming 结对编程](#pair-promgramming-结对编程)
    - [stand up  站立会议](#stand-up--站立会议)
    - [函数式编程](#函数式编程)
    - [面对过程](#面对过程)
    - [Restful](#restful)
    - [互联网，因特网， 万维网 的区别](#互联网因特网-万维网-的区别)
    - [层 layer 结构](#层-layer-结构)
    - [ESB---中台--](#esb---中台--)
    - [微服务](#微服务)
    - [NO sql](#no-sql)
    - [云计算](#云计算)
    - [TPU](#tpu)
    - [消息队列](#消息队列)
    - [machine learning  VS  deep learning](#machine-learning--vs--deep-learning)
    - [知识图谱](#知识图谱)
    - [web 几乎是每两年需要  从头开始再学习一遍](#web-几乎是每两年需要--从头开始再学习一遍)
- [技术栈  更新飞快](#技术栈--更新飞快)

<!-- /TOC -->

## 运维的目的， ---------稳定
		工作上，    1  处理掉所有的 告警，   出现   1 条  就能搞定（找 王梓，     1站在老板的角度，   监控是为了       系统稳定，  （减少告警， 保证稳定，  最好没有告警，这才是重要的） ）

## 运维 局限-------------与 公司 强耦合
		运维其实 就是维护你公司的 业务正常运转,    应用运维的活来说, 和公司的业务是强相关的,  强耦合的,          维护很多程序(你们公司的开发写的,程序出了什么问题, 开发自然知道是什么方面出了问题.),很多业务(你们公司特有 的逻辑),
		你在 这家公司的 经验,其实并不一定能保证你到下家公司有饭吃.    (相比开发就能随走随用.)      但是一些技术是想通的,基本的, 

## 互联网  的职位
		子主题 1
		
	运维开发
		应用运维。
		系统运维
		运维开发 
		 DBA
		 运维安全

## 计算机开发 速度之快--历史---  学习 才能赶上， 

专注技术栈
```		
可以说几乎2-3年就有一次"工业革命", 发生在这个行业的各个不同的角落:
从waterfall开发方式到敏捷的开发思想，再到Agile is Dead, DevOps的兴起...
从过程式的编程思想到OO 面向对象编程（Object-oriented Programming）)的兴起，再到FP 函数式编程（Functional Programming）慢慢渗透到现代语言的各个角落...
从RMI的失败，到WSDL和SOAP的兴起，再到RESTful…
从3层layer的单机构架，到SOA/ESB，再到SOA is Dead, 微服务兴起...
从实体物理机器，到VM虚拟机，再到docker+Kubernetes这种轻量级容器的兴起..
从SQL和Oracle的霸业，到NoSQL的兴起，再到NoSQL转向NewSQL...
从管理大型机5000个cpu的网格计算，到把计算资源当作自来水一样即开即用的云计算
从计算最多只能多线程的跑在cpu上，到hyperThread，GPU的大规模并行运算，再到TPU的大杀器…
从ActiveMq到SQS, Google pubsub这种完全用consistency换scalability的分布式队列，再到Kafka这种可以保证partition的strong ordering的分布式队列...

从RDFS到OWL，再到现在利用deep learning的知识图谱建造，和knowledge graph embedding…
从雇佣专门的部署和运维管理团队，到现在的infrastructure as code，network as code…
从认为流系统无法保证consistency的初始storm和2014年才问世的Lambda Architecture，到4种可以一定程度保证end2end consistency的state of art的流系统(仅仅4年后lambda architecture就被Stream System一书的作者按在地上摩擦)，再到提出流和batch/表有本质联系的google Dataflow模型…
即使是在很多人眼里还是新概念的"大数据", 也已经经历了Hadoop+MapReduce 到Pig/Hive这种高层模型，再到Spark, Flink的无数迭代了;
甚至从手调openCL手调cpu优化，到现在的autoTVM…
就更不用说machine Learning特别是deep Learning的大发展, 强化学习, 甚至量子计算机这些前沿领域了...
```

### agile 敏捷开发
				迭代开发
					迭代开发将一个大任务，分解成多次连续的开发，本质就是逐步改进。开发者先快速发布一个有效但不完美的最简版本，然后不断迭代。每一次迭代都包含规划、设计、编码、测试、评估五个步骤，不断改进产品，添加新功能。通过频繁的发布，以及跟踪对前一次迭代的反馈，最终接近较完善的产品形态。
					举例来说，SpaceX 公司想造一个大推力火箭，将人类送到火星。但是，它不是一开始就造大火箭，而是先造一个最简陋的小火箭 Falcon 1。结果，第一次发射就爆炸了，直到第四次发射，才成功进入轨道。然后，开发了中型火箭 Falcon 9，九年中发射了70次。最后，才开发 Falcon 重型火箭。如果 SpaceX 不采用迭代开发，它可能直到现在还无法上天。
				 增量开发
					迭代开发只是要求将开发分成多个迭代，并没有回答一个重要的问题：怎么划分迭代，哪个任务在这个迭代，哪个任务在下个迭代？这时，一般采用"增量开发"（incremental development）划分迭代。

所谓"增量开发"，指的是软件的每个版本，都会新增一个用户可以感知的完整功能。也就是说，按照新增功能来划分迭代
					 举例来说，房产公司开发一个10栋楼的小区。如果采用增量开发的模式，该公司第一个迭代就是交付一号楼，第二个迭代交付二号楼......每个迭代都是完成一栋完整的楼。而不是第一个迭代挖好10栋楼的地基，第二个迭代建好每栋楼的骨架，第三个迭代架设屋顶......

增量开发加上迭代开发，才算真正的敏捷开发
				其它 说明
					 每次迭代都必须依次完成以下五个步骤。

需求分析（requirements analysis）
设计（design）
编码（coding）
测试（testing）
部署和评估（deployment / evaluation）
					 五、敏捷开发的价值观
《敏捷软件开发宣言》里面提到四个价值观。

程序员的主观能动性，以及程序员之间的互动，优于既定流程和工具。
软件能够运行，优于详尽的文档。
跟客户的密切协作，优于合同和谈判。
能够响应变化，优于遵循计划。
					 六、十二条原则
该宣言还提出十二条敏捷开发的原则。

通过早期和持续交付有价值的软件，实现客户满意度。
欢迎不断变化的需求，即使是在项目开发的后期。要善于利用需求变更，帮助客户获得竞争优势。
不断交付可用的软件，周期通常是几周，越短越好。
项目过程中，业务人员与开发人员必须在一起工作。
项目必须围绕那些有内在动力的个人而建立，他们应该受到信任。
面对面交谈是最好的沟通方式。
可用性是衡量进度的主要指标。
提倡可持续的开发，保持稳定的进展速度。
不断关注技术是否优秀，设计是否良好。
简单性至关重要，尽最大可能减少不必要的工作。
最好的架构、要求和设计，来自团队内部自发的认识。
团队要定期反思如何更有效，并相应地进行调整

### Waterfall 模式
				Waterfall模式：因为只需要在最后给客户成品，时间充裕，能在一开始做详细计划，做出的画册质量更好，风格更统一，风只是因为后来无法和客户联系，有的地方没满足客户要求，而且老师说如果客户要求提前交付，waterfall模式没法像Agile那样出成品
Agile模式，每15分钟就需要出一个成品，所以一直都很慌乱，为了赶进度，没法做很详细的规划，每个人都按自己的理解做，导致每页画册风格不统一，总体质量不如waterfall画册的质量，但有个好处是，在第二次出成品时，客户提了新的要求，这样还能在最终版调整来满足客户要求
从游戏来看，大家更偏向waterfall模式，毕竟画册的质量更好，但现实的大环境都在主推Agile，因为时间就是金钱，都想先抢占先机，不知道Agile模式发展咋样

### DevOps
				
					DevOps是一种文化，它促进开发和运营团队之间的协作，以自动化和可重复的方式更快地将代码部署到生产中。“DevOps”这个词是“Development”和“Operations”这两个词的组合简写。

简而言之，DevOps可以定义为开发和IT运营的一致性，以及更好的沟通和协作
				why 
					开发人员和运营工程师是两个不同的组织团队，如果发现这两个团队在错误的轨道上协作，则表明需要DevOps。以下是两个团队经常出现的一些问题：

在DevOps之前，开发和运营团队完全孤立。测试和部署是在设计构建之后完成的独立活动。因此，他们比实际构建周期消耗更多时间。在不使用DevOps的情况下，团队成员将大量时间花在测试，部署和设计上，而不是构建项目。手动代码部署会导致生产中出现人为错误编码和运营团队有各自的时间表，不同步导致进一步的延误。
需要提高业务利益相关者的软件交付率。根据Forrester Consulting Study，只有17%的团队可以足够快地使用交付软件。这说明了软件开发是有痛点的。
如果有下面几种情况，就可以考虑使用DevOps了：

开发团队无法在开发早期发现软件缺陷。敏捷方法用于加速软件开发过程，但是一旦应用程序进入生产部门，所有方法都会变得无效。测试和开发团队成员无法及时访问资源，因此开发过程会延迟。您无法确定开发，测试和生产部门的确切问题。简单的人为错误通常会在开发和部署过程中产生障碍。一旦应用程序投入生产，开发人员就会认为他们的工作已经结束。在问题发生时，开发和运营团队开始互相指责。
					敏捷开发（Agile Development）、持续集成（Continuous Integration）、持续交付（Continuous Delivery）和开发运维一体化（DevOps），所覆盖的软件生命周期的阶段不同
				 工具
					自动化所有测试流程并对其进行配置以实现速度和灵活性至关重要。此过程称为DevOps自动化。维护庞大的IT基础架构的大型DevOps团队面临的困难可以简要分为六个不同的类别。

基建自动化
配置管理
部署自动化
绩效管理
日志管理
监测

下面我们来看看每个类别中的一些工具以及它们如何解决痛点 - 
1. 基建自动化亚马逊网络服务(AWS)：作为云服务，无需实际存在于数据中心。此外，它们易于按需扩展。没有前期硬件成本。它可以配置为自动根据流量配置更多服务器。
2. 配置管理Chef：它是一个有用的DevOps工具，用于实现速度，规模和一致性。它可用于简化复杂任务并执行配置管理。使用此工具，DevOps团队可以避免在一万台服务器上进行更改。他们只需要在一个地方进行更改，这些更改会自动反映在其他服务器中。
3. 部署自动化Jenkins：该工具有助于持续集成和测试。通过在部署构建后快速查找问题，它有助于更轻松地集成项目更改。
4. 日志管理Splunk：这是一个工具，可以解决在一个地方聚合，存储和分析所有日志的问题。
5. 绩效管理App Dynamic：它是DevOps工具，提供实时性能监控。此工具收集的数据可帮助开发人员在发生问题时进行调试。
6. 监控Nagios：确保在基础架构和相关服务出现故障时通知人员也很重要。Nagios就是这样一种工具，它可以帮助DevOps团队找到并纠正问题。

### pair-promgramming 结对编程
				pair 做事， 包括 分析，写测试，写代码或重构，   
两个人一起探讨容易产生思想的火花，也不容易走上 偏路

### stand up  站立会议
				项目组所有成员都会站立进行一次会议，  由于是站立的， 所以时间不会很长， 15--20min。 
1 你今天做了什么， 2你明天要做什么， 3 你遇到了哪些困难？ 
团队进行交流， 彼此熟悉工作内容， 若有曾经类似的 问题，还能讨论解决。 

### 函数式编程
				  我 之所以对函数式代码感兴趣是因为函数式代码富有表现力，可以使用简短、紧凑的代码完成工作，同时能对特定的问题给出优雅的解决方案。现代的编程语言不约而 同的朝着面向对象、函数式、动态、解释执行的方向发展，例如Ruby,Swift。而另一些语言则更加强调函数式编程，如F#,Scala，这种语言有着 强大的类型推断系统，编写的代码洁程度则令人叹为观止。

在F#编写一个两个数相加的函数，在F# Interactive中输入：

let add num1 num2=num1*num2;;
F# Interactive为我们推断了这个函数类型：val add : num1:int -> num2:int -> int，表示add有两个int类型的参数得到了1个int类型。

函数当作参数：

        //C#
        private int Twice(int input,Func f)
        {
            return f(f(input));
        }
        var result = Twice(2, n => n*n);
使用F#则只需要非常简洁的一个函数声明：

> let twice (input:int) f=f(f(input));;

val twice : input:int -> f:(int -> int) -> int

> twice 2 (fun n->n*n);;
val it : int = 16
val twice : input:int -> f:(int -> int) –> int 这句话则是F# Interactive给出的推断：twice函数需要一个int参数和一个(int->int)的函数作为参数，返回一个int.

这两个例子仅仅是热身，并不是本篇博客的重点，所以你觉得前两个例子很无聊或者没太看明白请继续看下面的总结。

场景：某种活动会有一个日程安排(Schedule)，日程安排有3中类型，只举办一次(Once)，每天一次(Daily)，每周一次(Weekly)。活动会根据日程安排(Schedule)的类型不同具有不同的宣传内容，不同的延期举行策略。

你对于这样的场景会有怎么样的思考呢？

一、面向过程类型的编码方式

面向过程类型的编码是需求的直译过程，代码会写成这样：

1.显示活动的宣传内容：

        public void ShowScheduleDescriptions()
        {
            switch (ScheduleType)
            {
                case ScheduleType.Once:
                    Console.WriteLine("this is once activity");
                    break;
                case ScheduleType.Daily:
                    Console.WriteLine("this is daily activity");
                    break;
                case ScheduleType.Weekly:
                    Console.WriteLine("this is weekly activity");
                    break;
                default:
                    throw new InvalidOperationException("unsupported schedule");
            }
        }
这样的代码初次看起来没什么问题，实际存在两个危险信号：

违反开放封闭（OCP)原则，如果有一天需要加入一种Monthly类型，无疑需要修改这个方法；
这样的代码风格会让接下来的开发者不假思索的进行延续，比方说需要根据不同的活动类型延期活动；
2. 延期活动：

        public void DelaySchedule()
        {
            switch (ScheduleType)
            {
                case ScheduleType.Once:
                    Console.WriteLine("Delay one hour");
                    break;
                case ScheduleType.Daily:
                    Console.WriteLine("Delay one day");
                    break;
                case ScheduleType.Weekly:
                    Console.WriteLine("Delay one week");
                    break;
                default:
                    throw new InvalidOperationException("unsupported schedule");
            }
        }
这样的代格违反了DRY原则，相同的代码框架却无法重用。

二、面向对象的编码方式

对于一个有经验的OO开发者，一旦看到switch，if(type=typeof(…))之类的代码马上会提高警惕，是不是有一些抽象类型没有被找出来？在这个例子中则会找出下面的抽象：

    
    public  class Schedule
    {
        public virtual void ShowShowScheduleDescriptions()
        {
        }

        public virtual void DelaySchedule()
        {
        }
    }

    public class OnceSchedule : Schedule
    {
        public override void ShowShowScheduleDescriptions()
        {
            Console.WriteLine("this is once activity");
        }

        public override void DelaySchedule()
        {
            Console.WriteLine("Delay one hour");
        }
    }

    public class DailySchedule : Schedule
    {
        public override void ShowShowScheduleDescriptions()
        {
            Console.WriteLine("this is daily activity");
        }

        public override void DelaySchedule()
        {
            Console.WriteLine("Delay daily day");
        }
    }

    //... other schedule
这样的代码很好的解决了面向过程代码的两个问题，看起来更加具有扩展性，随着新类型的Schedule引入，旧的代码完全不用改动。

当然事情也不是绝对的，什么情况下需要改动旧代码呢？当需要扩展Schedule的行为的时候，例如需求升级，不同的Schedule具有不同的举办方式，我们不得不在每种Schedule中加入一个 void Hold()方法。

三、函数式解决方案

函数式语言则使用可区分联合和模式匹配来处理此类问题。

定义一个Schedule可区分联合：

type Schedule=
| Once of DateTime
| Daily of DateTime*int
| Weekly of DateTime*int
这个类型既说明了Schedule有三个不同的类型，同时定义了三种类型分别具有的数据结构。像是Enum和类的综合体，但是又显得特别精致。

1.显示活动的宣传内容，使用了模式匹配：

let ShowShowScheduleDescriptions schedule=
match schedule with
| Once(DateTime)-> printfn "this is once activity"
| Daily(DateTime,int)->printfn "this is daily activity"
| Weekly(DateTime,int)->printfn "this is weekly activity"
这个方法类似于switch…case，但是通过匹配可区分联合来实现，而不是通过一个显示的Enum来实现。

2. 延期活动：

let DelaySchedule schedule=
match schedule with
| Once(DateTime)-> printfn "Delay one hour"
| Daily(DateTime,int)->printfn "Delay one day"
| Weekly(DateTime,int)->printfn "Delay one week"
函数式编程的解决方案认为可以很方便的添加新的行为，例如增加新的行为：Hold()。通过定义可区分联合和模式匹配来完成编码，整个解决方案像是面向过程和面向对象的一种结合体，但是侧重点不同，实现的代码也更加精致
				http://www.voidcn.com/article/p-adjydlhd-dr.html

### 面对过程
				二：面向过程
找到解决问题的入口，按照一个固定的流程去模拟解决问题的流程

1.搜索目标，用户输入（配偶要求），按找要求到数据结构（字典）内检索合适的人物
2.表白，表白成功进入3，否则进入2
3.恋爱，恋爱成功进入4，否则返回1
4.见家长，家长同意进入5，家长说她是你失散多年的妹妹，返回1
5.结婚

违反开放封闭（OCP)原则，如果有一天需要加入一种Monthly类型，无疑需要修改这个方法；
这样的代码风格会让接下来的开发者不假思索的进行延续，比方说需要根据不同的活动类型延期活动；
这样的代格违反了DRY原则，相同的代码框架却无法重用
			 面对对象
				三：面向对象：
人:
属性：身高，体重，颜值，财富，学历，性取向
方法：
吃饭，说话，睡觉，表白，结婚

恋爱系统：
属性：

### Restful 
				
RMI(remote method invocation，面向对象的远程方法调用)
RPC（remote procedure call，远程过程调用）
SOAP(simple object access protoal，简单对象访问协议)
REST(representational state transfer，表达性状态转移)
可以都理解为调用远程方法的一些通信技术“风格”：

RMI就好比它是本地工作，采用tcp/ip协议，客户端直接调用服务端上的一些方法。优点是强类型，编译期可检查错误，缺点是只能基于JAVA语言，客户机与服务器紧耦合。

RPC使用C/S方式，采用http协议，发送请求到服务器，等待服务器返回结果。这个请求包括一个参数集和一个文本集，通常形成“classname.methodname”形式。优点是跨语言跨平台，C端、S端有更大的独立性，缺点是不支持对象，无法在编译器检查错误，只能在运行期检查。

SOAP是在XML-RPC基础上，使用标准的XML描述了RPC的请求信息（URI/类/方法/参数/返回值）。因为XML-RPC只能使用有限的数据类型种类和一些简单的数据结构，

SOAP能支持更多的类型和数据结构。优点是跨语言，非常适合异步通信和针对松耦合的C/S，缺点是必须做很多运行时检查。REST一般用来和SOAP做比较，它采用简单的URL方式来代替一个对象，优点是轻量，可读性较好，不需要其他类库支持，缺点是URL可能会很长，不容易解析
				 REST对于资源型服务接口来说很合适，同时特别适合对于效率要求很高，但是对于安全要求不高的场景。而SOAP的成熟性可以给需要提供给多开发语言的，对于安全性要求较高的接口设计带来便利。所以我觉得纯粹说什么设计模式将会占据主导地位没有什么意义，关键还是看应用场景，正是那句老话：适合的才是最好的
			 https://github.com/www1350/javaweb/issues/56
			 只需要搞清楚
传输层:如何传输,一般基于tcp,协议层:传过来后如何读数据就可以;
协议层:
文本类:xml,json
二进制:protobuf,thrift,mcpack等
传输层:
http;
各种自定义协议;

### 互联网，因特网， 万维网 的区别
				 互联网、因特网、万维网三者的关系是：

互联网包含因特网，因特网包含万维网，凡是能彼此通信的设备组成的网络就叫互联网。所以，即使仅有两台机器，不论用何种技术使其彼此通信，也叫互联网。国际标准的互联网写法是Internet，字母i一定要大写！因特网是互联网的一种。因特网可不是仅有两台机器组成的互联网，它是由上千万台设备组成的互联网。因特网使用TCP/IP协议让不同的设备可以彼此通信。但使用TCP/IP协议的网络并不一定是因特网，一个局域网也可以使用TCP/IP协议。判断自己是否接入的是因特网，首先是看自己电脑是否安装了 TCP/IP协议，其次看是否拥有一个公网地址(所谓公网地址，就是所有私网地址以外的地址)。

因特网是基于TCP/IP协议实现的，TCP/IP协议由很多协议组成，不同类型的协议又被放在不同的层，其中，位于应用层的协议就有很多，比如FTP、SMTP、HTTP。只要应用层使用的是HTTP协议，就称为万维网(World Wide Web)。之所以在浏览器里输入百度网址时，能看见百度网提供的网页，就是因为您的个人浏览器和百度网的服务器之间使用的是HTTP协议在交流

### 层 layer 结构 
https://www.cnblogs.com/youxin/archive/2013/05/20/3089095.html
				作用：分解复杂的软件系统

优点：1、降低复杂度，上层不需要关注下层细节。

             2、提高灵活性，可以灵活替换某层的实现。

             3、减小耦合度，将层次间的依赖减到最低。

 4、有利于重用，同一层次可以有多种用途。

 5、有利于标准化。

缺点：1、不能封装所有工作，可能会带来及联修改。

 2、过多层次影响性能。

难点：1、如何划分层次。

 2、定义层次职责。
				分层（Layer）模式是最常见的一种架构模式。甚至说分层模式是很多架构模式的基础，本章下面讲到的一些内容实际上都和分层模式相关联。
分层描述的是这样一种架构设计过程：从最低级别的抽象开始，称为第1层。这是系统的基础。通过将第J层放置在第J-1层的上面逐步向上完成抽象阶梯，直到到达功能的最高级别，称为第N层。

因而分层模式就可以定义为：将解决方案的组件分隔到不同的层中。每一层中的组件应保持内聚性，并且应大致在同一抽象级别。每一层都应与它下面的各层保持松散耦合。


分层模式的关键点在于确定依赖：即通过分层，可以限制子系统间的依赖关系，使系统以更松散的方式耦合，从而更易于维护。
相对于分层，还有一种概念叫分区。分层是对架构的横向划分，而分区是对架构的纵向划分。
			
### ESB---中台--
ESB是企业服务总线的缩写，而SOA的意思是面向服务架构  https://zato.io/docs/intro/esb-soa-cn.html  
				如果一个给定的功能系统要做成服务，需要满足以下这三个条件：

有趣 I nteresting
可重用 R eusable
原子性 A tomic
			 微服务
缺点是容易 膨胀，   

所以采用了中台

### 微服务
微服务是一种架构风格，一个大型复杂软件应用由一个或多个微服务组成。系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。每个微服务仅关注于完成一件任务并很好地完成该任务。在所有情况下，每个任务代表着一个小的业务能力
				https://www.zhihu.com/question/65502802      

### NO sql
				这里把常见的NoSQL分为4类：K-V类、文档型、列式存储型、全文搜索型
			 数据库 索引  https://blog.csdn.net/weiliangliang111/article/details/51333169

### 云计算 
				云计算（cloud computing，台湾译作云端运算），是分布式计算技术的一种，其最基本的概念，是透过网络将庞大的计算处理程序自动分拆成无数个较小的子程序，再交由多部服务器所组成的庞大系统经搜寻、计算分析之后将处理结果回传给用户。透过这项技术，网络服务提供者可以在数秒之内，达成处理数以千万计甚至亿计的信息，达到和“超级计算机”同样强大效能的网络服务。

　　云计算是一种资源交付和使用模式，指通过网络获得应用所需的资源（硬件、平台、软件）。提供资源的网络被称为“云”。“云”中的资源在使用者看来是可以无限扩展的，并且可以随时获取。这种特性经常被比喻为像水电一样使用硬件资源，按需购买和使用。[1]（Cloud computing is a resource delivery and usage model, it means get resource (Hardware, software)via network. The network of providing resource is called ‘Cloud’. The hardware resource in the ‘Cloud’ seems scalable infinitely and can be used whenever.）[2]

　　最简单的云计算技术在网络服务中已经随处可见，例如搜寻引擎、网络信箱等，使用者只要输入简单指令即能得到大量信息
				 云计算(Cloud Computing)是分布式处理(Distributed Computing)、并行处理(Parallel Computing)和网格计算(Grid Computing)的发展，或者说是这些计算机科学概念的商业实现。

云计算的基本原理是，通过使计算分布在大量的分布式计算机上，而非本地计算机或远程服务器中，企业数据中心的运行将更与互联网相似。这使得企业能够将资源切换到需要的应用上，根据需求访问计算机和存储系统。

这可是一种革命性的举措，打个比方，这就好比是从古老的单台发电机模式转向了电厂集中供电的模式。它意味着计算能力也可以作为一种商品进行流通，就像煤气、水电一样，取用方便，费用低廉。最大的不同在于，它是通过互联网进行传输的。

### TPU 
				张量处理单元 (TPU) 是 Google 定制开发的专用集成电路 (ASIC)，用于加速机器学习工作负载。Google 结合机器学习领域的丰富经验与领先优势，从零开始打造了这些 TPU。

借助 Cloud TPU，您将能够使用 TensorFlow 在 Google 的 TPU 加速器硬件上运行机器学习工作负载。Cloud TPU 旨在实现最高性能与灵活性，帮助研究人员、开发者和企业构建可使用 CPU、GPU 和 TPU 的 TensorFlow 计算集群。高级 Tensorflow API 可帮助您在 Cloud TPU 硬件上运行模型。

TPU 的优点
Cloud TPU 资源提高了机器学习应用中大量使用的线性代数计算的性能。在训练大型复杂的神经网络模型时，TPU 可以最大限度地缩短达到准确率所需的时间。以前在其他硬件平台上需要花费数周时间进行训练的模型，在 TPU 中只需数小时即可收敛
				作者：知乎用户
链接：https://www.zhihu.com/question/46692744/answer/158897410
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

被TPU论文引用过的人顶着赶论文的压力强行来答一波。先说一句题外话。。。这个世界是一个罗生门，每个人都在自说自话。学术圈的一小部分人也不能完全免俗，而科技圈 99% 的人都不免俗。每一套话语背后都有一个隐含的框框，只有掌握全部事实，才有可能跳出框框，获得真相。-----------------------我是分割线----------------------我是属于体系结构圈子里第一波（大约是2012~2013年之间）开始做神经网络加速器的。同一时间我知道的工作还有中科院陈云霁老师和清华的汪玉老师。总的来说，TPU这次论文有很多有趣的信息，但性能并没有什么好惊艳的。我拎出一些值得注意的地方说一说。-----------------------我是分割线----------------------1. 关于TPU和GPU的对比，以及一些争吵。吵来吵去，其实就是两点，性能和功能。性能是说 Performance 和 Performance/Watt，功能是说 Training 和 Inference 。TPU宣称自己 Performance / Watt 远高于GPU（大约25倍）。N家掌门人老黄立刻说你们用K80 比是不厚道的；你们的性能仅仅是 P40 的两倍而已，Performance / Watt 仅仅是 6倍。而且还不支持浮点和训练。媒体圈加科技圈就开始热闹非凡，资本圈早就暗流涌动抢着投钱做ASIC。总的来说，TPU和GPU不是谁取代谁的问题（敲黑板！）而是各自都有生存的空间，谁也不能取代谁。比一比性能只是互相学习和参照罢了。---- 吐槽人家只做 Inference 是不对的！大部分的训练算法都在后台运行，快速的部署和训练迭代是最关心的问题。N家的生态环境和性能都已经做得很好了，我怀疑Google 有没有动力非要自己做一个训练的加速器。而用于在线服务/终端的 inference 的重要性我就不多说了，90%的设备都用来做 inference 以提供实际服务了。P40的GPU是不可能插在在线服务端的，数据中心的功耗限制大多数都在 100 w 以下，有的甚至只有50w，比如 MS 和 FB。嵌入式端就更是这样了，手机和无人机，在应用需求真正起来之后，我们是可以展望另一种形式的TPU被集成的。当然，这一天也不会来的太快。毕竟TPU太专用了，目前只有Google这样体量的公司，会有应用这种专用加速的动力。---- 只比较性能（Tera Operations / Sec）是不全面的！只比较 Performance / Watt 也是不对的！刚才说了。不能单纯做除法，50 Watt，5Watt，3Watt，都是云端/嵌入式终端的硬性限制。满足这个限制基础上，再来谈 Performance / Watt 才有意义。另一方面，TPU一片才几百刀，老黄家GPU动辄几千上万刀。难怪大体量的数据中心会选择自己做芯片。太划算了 ！数据中心的功耗密度已经是一个非常严峻的问题了。微软采用了FPGA的路子是另一条有趣的技术路线。成功与困难并存。大家可以移步李博杰大神的文章（如何评价微软在数据中心使用FPGA代替传统CPU的做法？ - 知乎）讲的很透彻。所以，我很好奇。老黄为何用 P40 做比较。P4 不是更好么？22 TOPs（INT8）的性能，50 Watt。跟 Google TPU 的  Performance / Watt 的比较，只有 4x 的差距。2. 关于TPU的一些有趣的观察。----- a) 正确分析处理器带宽很重要。号称 90 TOPS 的性能。在 MLP 上只有 10 TOPs 的实际性能。而Google又号称 MLP 占据了 60%的应用。这才是真正的槽点。敢情只有 1/9 的性能被用上了。其实原因也简单，主要是被带宽限制住了，34GB/s 还有很大改进空间。改到 340GB/s就能用上剩下 8/9了。因为带宽问题，文中大量出现 Roofline Model，但却被大家忽略了。我们在北京大学的工作，是世界上第一个提出使用 Roofline Model 对神经网络加速器进行设计优化的（ 最初的Roofline Model 由David Patterson老爷子提出，他也是TPU作者之一）。可惜这个概念目前还没有被大家很好地使用，目前只有TPU和我们的工作使用了Roofline Model。------ b) 8 Bit 的做法在当时很激进。算上论文发表的时间，算上ASIC设计与迭代周期等等，Google在秘密开始TPU项目可能是在2015年以前（个人猜测）。那个时间段做 8 Bit 真的是非常激进了。学术圈（计算机视觉）里的低定点化研究大约在2016 年才出现。（更新：以下猜测并不准确，请大家移步贾扬清大神的评论）猜测TPU也有可能以浮点设计开始，到2016年才开始改成定点的。如果是这样，那么从学术圈研究到工业界的应用，只用了一年不到的时间。而且还是代价巨大的ASIC，Google这么做确实吓人一跳。当然，这一跳不是在看到论文时吓的。圈里早就传说TPU是 8-Bit了。更新一下贾扬清大神的评论：Google是在2013年左右开始研发TPU，而且当时就确定了8bit计算的方法，当时敢上8bit的缘故是speech证明了8bit可行（可以参见Vanhoucke的论文），所以的确还是很先进的。
（都是公开信息，没有内幕）----- c) TPU文中许多应用的存储量都很小。5M-100MB的参数，片上再挤一挤其实也能放下了。一方面，模型的压缩和稀疏化能够派上用场了。另一方面，可以使用有两块/多块芯片，各自处理神经网络的一部分。这样即使有很大的权重，也可以通过分配到多个芯片的缓存上，来解决这个问题。这样就没有带宽的后顾之忧了。这也将是很有意思的研究方向。当然这件事工程上并不容易，我们在多FPGA上进行了一些探索，但是ASIC上暂时还没有看到公开发表的研究。----- d) TPU不是终点，而只是开始。神经网络算法一直在演变和发展，这套方法的理论还不成熟，应用场景也会在未来几年发生巨大的变化。大家可以想象一下安防、无人机、智慧大楼、无人驾驶，等等等等。每一个子领域都有 系统/功耗/性能 一系列问题和各种权衡。一方面，是算法多变的情况下，如何发掘计算的内在并行性，又给上层程序员提供一个高效的编程接口，是一个很重要很实际的问题。另一方面，也有可能会做得极其定制化。牺牲大量编程性以求极低的功耗和性能，比如手机上专门做一个只识别人脸的芯片。未来很精彩，让我们拭目以待。

### 消息队列
				有一天，产品跑来说：“我们要做一个用户注册功能，需要在用户注册成功后给用户发一封成功邮件。”

小明（攻城狮）：“好，需求很明确了。” 不就提供一个注册接口，保存用户信息，同时发起邮件调用，待邮件发送成功后，返回用户操作成功。没一会功夫，代码就写完了。验证功能没问题后，就发布上线了。

线上正常运行了一段时间，产品匆匆地跑来说：“你做的功能不行啊，运营反馈注册操作响应太慢，已经有好多用户流失了。”

小明听得一身冷汗，赶紧回去改。他发现，原先的以单线程同步阻塞的方式进行邮件发送，确实存在问题。这次，他利用了 JAVA 多线程的特性，另起线程进行邮件发送，主线程直接返回保存结果。测试通过后，赶紧发布上线。小明心想，这下总没问题了吧。

没过多久，产品又跑来了，他说：“现在，注册操作响应是快多了。但是又有新的问题了，有用户反应，邮件收不到。能否在发送邮件时，保存一下发送的结果，对于发送失败的，进行补发。”

小明一听，哎，又得熬夜加班了。产品看他一脸苦逼的样子，忙说：“邮件服务这块，别的团队都已经做好了，你不用再自己搞了，直接用他们的服务。”

小明赶紧去和邮件团队沟通，谁知他们的服务根本就不对外开放。这下小明可开始犯愁了，明知道有这么一个服务，可是偏偏又调用不了。

邮件团队的人说，“看你愁的，我给你提供了一个类似邮局信箱的东西，你往这信箱里写上你要发送的消息，以及我们约定的地址。之后你就不用再操心了，我们自然能从约定的地址中取得消息，进行邮件的相应操作。”

后来，小明才知道，这就是外界广为流传的消息队列。你不用知道具体的服务在哪，如何调用。你要做的只是将该发送的消息，向你们约定好的地址进行发送，你的任务就完成了。对应的服务自然能监听到你发送的消息，进行后续的操作。这就是消息队列最大的特点，将同步操作转为异步处理，将多服务共同操作转为职责单一的单服务操作，做到了服务间的解耦。

哈哈，这下能高枕无忧了。太年轻，哪有万无一失的技术啊~

不久的一天，你会发现所有业务都替换了邮件发送的方式，统一使用了消息队列来进行发送。这下仅仅一个邮件服务模块，难以承受业务方源源不断的消息，大量的消息堆积在了队列中。这就需要更多的消费者（邮件服务）来共同处理队列中的消息，即所谓的分布式消息处理。
				  https://github.com/jasonGeng88/blog/blob/master/201705/MQ.md

### machine learning  VS  deep learning
				https://www.zhihu.com/question/57770020

### 知识图谱 
				https://zhuanlan.zhihu.com/p/31726910
				 https://zhuanlan.zhihu.com/p/31864048

### web 几乎是每两年需要  从头开始再学习一遍

## 技术栈  更新飞快
1 要有限   ----  无限的东西 死循环
2 统一标准---才能方便 转化为  --- 互联网信息数据 （数据结构，类型，格式）
无论是 什么职位，  它的职位要求  都是 一直在变的，          -------  所以 要  紧随时代，   行业顶尖，   行业的 发展动态， 

跟随这个时代的变化
		你自己 要 长期  扎根 在 某个 技术栈， 长期 深入，。     成为这个领域的 专家。     人的  时间，精力有限，  要集中力量， 
		不同的 技术栈， 不同的领域 其实  都有用处，  你的技能达到顶尖， 自然是 不愁工作 的，      招聘的要求 其实是一直都有在 提升的，    重点 是 你的兴趣， 你的特长，