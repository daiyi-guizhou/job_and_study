http://www.ai-start.com/dl2017/－－－机器学习　doc文字

****
****
##### 概述
　　整个软件系统被划分为几个小的子系统，而每个小的子系统又划分为几个独立工作的由一组文件组成的模块时，就涉及到模块之间的协调问题。 
***（软件系统->子系统->模块）***
　　make工具的作用就是当一个模块被修改后，保证其他模块与之相关的部分也随之改变，进而不会影响模块之间的协调关系。

　　make本身是一个单独工作的程序，可以根据程序模块的修改情况重新编译链接目标代码，以保证目标代码总是由它的最新模块组成。

##### make命令和Makefile
[跟我一起写MakeFile](https://seisman.github.io/how-to-write-makefile/rules.html)
　　要使用make，必须编写一个称为Makefile的文件。它描述了软件包中各个文件之间的关系，提供了更新每个文件的命令。 
　　 
　　在一个软件包里，软件更新顺序： 
***可执行文件更新 <- 链接目标文件更新 <- 编译源文件更新***
　　Makefile的每个相关行说明一个目标依赖于哪几个文件，以及生成或更新目标时所需要的命令。 


##### cmake
[cmake, 入门实践](https://www.hahack.com/codes/cmake/)
它首先允许开发者编写一种平台无关的 CMakeList.txt 文件来定制整个编译流程，然后再根据目标用户的平台进一步生成所需的本地化 Makefile 和工程文件


MakeFile   ： 可以用来做 很多类似 bash 脚本的 事。




****
****

每个工具 都有自己的 语法，  每个 语法 都精通 事  一件 不可能的事：  
* 1 有什么用----***见识***
	* 通常用来做什么
	* 最牛的样子 可以做到什么程度
* 2 如何操作，如何上手，说明书， 
	* 善用搜索
	* 借鉴别人的例子， 跟着做是 高效率的学习
* 3 原理是什么， why？？ 
****
****
#### repo
Repo 可以在必要时整合 Git 代码库，将相关内容上传到我们的 Gerrit 修订版本控制系统，并自动执行 Android 开发工作流程的部分环节。Repo 并非用来取代 Git，只是为了让您在 Android 环境中更轻松地使用 Git。repo 命令是一段可执行的 Python 脚本，您可以将其放在路径中的任何位置。使用 Android 源代码文件时，您可以使用 Repo 执行跨网络操作。例如处理单个 Repo 工作目录。

在大多数情况下，您可以仅使用 Git（不必使用 Repo），或结合使用 Repo 和 Git 命令以组成复杂的命令。不过，使用 Repo 执行基本的跨网络操作可大大简化您的工作。如需详细了解 Repo，请参阅 Repo 命令参考资料和 Repo README。
***
***
#### 格式化代码
requirements.txt
```
yapf==0.28.0
isort==4.3.21
```
MakeFile
```
.PHONY: install
install:
	pip install -r requirements.txt

.PHONY: fmt
fmt:
	yapf --exclude services/sls-backend-server/init_sls_cluster/conf.tmpl -p -i -r .
	isort --skip services/sls-backend-server/init_sls_cluster/conf.tmpl -rc .
```
```
yapf -p -i -r .
isort -rc .    

(如何忽略掉 某些 文件 或 目录.)
yapf --exclude services/conf.tmpl -p -i -r .
isort --skip services/conf.tmpl -rc .


(如果需要忽略多个文件)
yamf
Excluding files from formatting (.yapfignore)
In addition to exclude patterns provided on commandline, YAPF looks for additional patterns specified in a file named .yapfignore located in the working directory from which YAPF is invoked.
_____________
isort 
 -s SKIP, --skip SKIP  Files that sort imports should skip over. If you want
                        to skip multiple files you should specify twice:
                        --skip file1 --skip file2.
```
sort 同样也可以用配置文件
Configuring isort
If you find the default isort settings do not work well for your project, isort provides several ways to adjust the behavior.

To configure isort for a single user create a ~/.isort.cfg or $XDG_CONFIG_HOME/isort.cfg file:
```
[settings]
line_length=120
force_to_top=file1.py,file2.py
skip=file3.py,file4.py
known_future_library=future,pies
known_standard_library=std,std2
known_third_party=randomthirdparty
known_first_party=mylib1,mylib2
indent='    '
multi_line_output=3
length_sort=1
forced_separate=django.contrib,django.utils
default_section=FIRSTPARTY
no_lines_before=LOCALFOLDER
```

Additionally, you can specify project level configuration simply by placing a .isort.cfg file at the root of your project. isort will look up to 25 directories up, from the file it is ran against, to find a project specific configuration.

在你的项目中， 需要执行 sort 的当前目录， 粗暴的来一个 .isort.cfg 文件。
```
[settings]
skip=src/common/tianji/tianji_clt.py,\
        src/scale_down_sls_cluster_ag/sls_deploy_common.py,\
        src/scale_down_sls_cluster_ag/sls_op_common.py,\
        src/scale_down_sls_cluster_ag/sls_worker_scaling_016.py,\
        src/scale_down_sls_cluster_ag/sls_worker_shutdown_machine.py,\
        src/scale_down_sls_cluster
```
***
***
class Name(object)  与 class Name()   有无 object 的差别
	https://my.oschina.net/zhengtong0898/blog/636468
	实际上在python 3 中已经默认就帮你加载了object了（即便你没有写上object）。
****
****
switchyomega  + chrome 插件代理.    ---- ip 代理
***
***
python
	`argparse  模块， 用来对你的函数 执行的参数 做封装的。 `
```
	try:
    import json
except:
```
```
    import simplejson as json
	unittest自动化测试的  模块。
		import unittest

class TestStringMethods(unittest.TestCase):

    def test_upper(self):
        self.assertEqual('foo'.upper(), 'FOO')

    def test_isupper(self):
        self.assertTrue('FOO'.isupper())
        self.assertFalse('Foo'.isupper())

    def test_split(self):
        s = 'hello world'
        self.assertEqual(s.split(), ['hello', 'world'])
        # check that s.split fails when the separator is not a string
        with self.assertRaises(TypeError):
            s.split(2)

if __name__ == '__main__':
    unittest.main()
	sys.path.append()  添加路径， 方便导入其它路径的模块。
		sys.path.append(FILE_PATH + "/data_sdk_v4")
```
```
	 hashlib.md5()
		import hashlib         #导入hashlib模块

md = hashlib.md5()     #获取一个md5加密算法对象
md.update('how to use md5 in hashlib?'.encode('utf-8'))                   #制定需要加密的字符串
print(md.hexdigest())  #获取加密后的16进制字符串
```
### package 打包
[浅谈setuptools之namespace package概念](https://blog.csdn.net/eliz_jack/article/details/51812492)
[setuptools 文档](https://setuptools.readthedocs.io/en/latest/setuptools.html?highlight=namespace#namespace-packages)

